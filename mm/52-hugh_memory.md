随着硬件能力的提升，系统内存容量变得越来越大。尤其是在服务器上，过T级别的内存容量也已经不罕见了。

如此海量内存给内核带来了什么样的挑战呢？我们来粗略得看一下。

# page struct 分配

在内核中，我们将物理内存按照页大小进行管理。这样每个页就对应一个page struct作为这个页的管理数据结构。

随着内存容量的增加，相对应的page struct也就增加。而这部分内存和其他的内存略有不同，因为这部分内存不能给到页分配器。也就是必须在系统能够正常运行起来之前就分配好。

在内核中我们可以看到，为了应对这样的变化进化出了几个不同的版本。有幸的是，这部分内容我们现在还能在代码中直接看到。因为这个实现是通过内核配置来区分的。就我理解的，这部分可以配置成：

  * CONFIG_FLATMEM
  * CONFIG_SPARSEMEM

对于第一种，page struct是一个大数组，所有的人都挨着。
而第二种就是在页的基础上又划分了section，每个section中指定了page struct的存储空间。

之所以这么做，是因为如果数组是静态数组，那么数组的大小不好设定，大了容易浪费，小了不够。采用了section后，只需要分配真实存在的内存对应的页结构就好了。

另外一个原因是如果数组是动态的，那么这个数组的大小将随着内存的增加而变大，在内存中找到这么大一段连续的内存空间将变得困难。在最近的进化中，已经把page struct的分配按照numa node来划分了。而且当这么分配再失败的化就按照section来分配。进一步减少了失败的可能。这一部分可以看函数sparse_init_nid()的实现。

# mem_section分配和初始化

```
    mem_section[NR_SECTION_ROOTS][SECTIONS_PER_ROOT]

    = [DIV_ROUND_UP(NR_MEM_SECTIONS, SECTIONS_PER_ROOT)] [SECTIONS_PER_ROOT]

        [0]          [1]                                [SECTIONS_PER_ROOT - 1]
        +------------+------------+        +------------+------------+
    [0] |            |            |   ...  |            |            |
        +------------+------------+        +------------+------------+

        +------------+------------+        +------------+------------+
    [1] |            |            |   ...  |            |            |
        +------------+------------+        +------------+------------+

        +------------+------------+        +------------+------------+
    [2] |            |            |   ...  |            |            |
        +------------+------------+        +------------+------------+
```

sparsemem的出现就是为了应对海量内存的，再带来优点的同时也带来了新的限制。

从上面的图中可以看到，mem_section是一个二维数组。最开始这个数组是一个静态数组。很明显这么做带来的问题是这个数组太大太小都不合适。所以后来这个数组就变成了动态的，当CONFIG_SPARSEMEM_EXTREME设置为y时。

上面这个算作是空间上的限制的话，那么接下来就是一个时间上的限制了。

在系统初始化时，每个mem_section都要和相应的内存空间关联。在老版本上，这个步骤通过对整个数组接待完成。原来的版本上问题不大，因为整个数组的大小还没有很大。但随着内存容量的增加，这个数值就变得对系统有影响了。如果系统上确实有这么多内存，那么确实需要初始化也就忍了。但是在内存较小的系统上，哪怕没有这么多内存，还是要挨个初始化，那就浪费了太多的时间。

```
commit c4e1be9ec1130fff4d691cdc0e0f9d666009f9ae
Author: Dave Hansen <dave.hansen@linux.intel.com>
Date:   Thu Jul 6 15:36:44 2017 -0700

    mm, sparsemem: break out of loops early
```

Dave在这个提交中增加了对系统最大存在内存的跟踪，来减少不必要的初始化时间。

# page struct 初始化

内核中，管理内存的单位是页，而这个页对应有一个page struct作为管理数据。在前文中我们讲了page struct在内存空间上带来的挑战。现在我们来看看在时间上带来的挑战。

在每个页能够被page allocator使用前，对应的page struct需要被初始化。随着页面的增加，要初始化的页就相应增加。

这个过程在memmap_init_zone()中可以看到，针对zone下的所有页都做了初始化。

为了加快系统的启动时间，内核中非常有意思的提出了延后初始化的方案。也就是在初始化时，只初始化部分的内存页，其余的页面在系统启动后再初始化。这样加快了系统启动的时间。

相关的函数有：defer_init(), deferred_init_memmap(), deferred_grow_zone()。
