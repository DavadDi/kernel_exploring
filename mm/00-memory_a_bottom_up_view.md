内存模块是内核中一个非常重要的部分。我们现在的计算机都被称作为**存储程序计算机**，也就是所有待运行的程序和数据都需要加载在内存当中方能被执行。正因为如此，很多朋友都希望学习内存模块的工作机制，但碍于内核代码的庞大以及文档的缺失和稀少，总是感觉无从下手。

经过一段时间的摸索，我终于对内存模块有了一点点的了解。今天整理成文，希望能给想要探究内存模块的朋友一点点借鉴。

# 内存模块的层次结构

首先内存模块具有一定层次结构的，从物理内存到软件控制的内存经过了几个层次的隔离。

[e820从硬件获取内存分布][1]

[原始内存分配器--memblock][2]

页分配器

Slub分配器

大致我们能看到这么四个层次的内存管理结构。前两者基本在内核启动时使用，而平时大多使用的是后两者。

# 页分配器的探究

页分配器是一个相对牵着概念较多的层次，也可以说正是这个层次把物理上的内存差异屏蔽，从而向用户呈现了一致的使用接口。

第一个让我好奇的是页结构体究竟是存放在哪里的？

最原始的版本中页结构体是作为一个大的静态数组存放在内存中的，而随着内存变大，空洞变多，静态数组显然不符合设计理念。之后则提出了SPARSEMEM的概念，按实际情况分配页结构体。

[寻找页结构体的位置][3]

所谓的内存物理差异无非就两点：

* 硬件是否能访问
* 访问速度的差异

而这两点对应到软件上的概念是：

* ZONE
* NUMA NODE

那内核中是如何把这两个信息保存起来，并用来指导内存非配的呢？

首先，系统为了获取NUMA信息，新增了numa_meminfo结构从硬件中获取NUMA信息，然后在转换到了memblock层。

[NUMA信息获取][4]

接下来就是大名鼎鼎的pg_data_t结构体出场了。所有的页分配工作都是基于这个数据结构的信息所作出的。

[Node-Zone-Page][5]

有了这样的概况之后，我们就可以来看看页是如何初始化和被分配的了。

[传说的伙伴系统][6]

# 参考文献

[Understand Linux VM][7]

[1]: /mm/01-e820_retrieve_memory_from_HW.md
[2]: /mm/02-memblock.md
[3]: /mm/03-sparsemem.md
[4]: /mm/04-numa_node_info.md
[5]: /mm/05-Node_Zone_Page.md
[6]: /mm/06-page_alloc.md
[7]: https://www.kernel.org/doc/gorman/html/understand/index.html
