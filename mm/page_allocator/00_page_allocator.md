# 页分配器的探究

页分配器是一个相对牵着概念较多的层次，也可以说正是这个层次把物理上的内存差异屏蔽，从而向用户呈现了一致的使用接口。

第一个让我好奇的是页结构体究竟是存放在哪里的？

最原始的版本中页结构体是作为一个大的静态数组存放在内存中的，而随着内存变大，空洞变多，静态数组显然不符合设计理念。之后则提出
 SPARSEMEM的概念，按实际情况分配页结构体。

[寻找页结构体的位置][3]

知道页结构体在那里，顺便来瞥一眼结构体的样子。为啥说是瞥一眼呢？因为这个结构体实在是太大（乱）了。为了满足各种需求，这个结构
 中进行了多重复用。先放在这里，作为一个参考文档把。

[眼花的页结构体][10]

所谓的内存物理差异无非就两点：

* 硬件是否能访问
* 访问速度的差异

而这两点对应到软件上的概念是：

* ZONE
* NUMA NODE

那内核中是如何把这两个信息保存起来，并用来指导内存非配的呢？

这就需要大名鼎鼎的pg_data_t结构体出场了。所有的页分配工作都是基于这个数据结构的信息所作出的。

[Node-Zone-Page][5]

有了这样的概况之后，我们就可以来看看页是如何初始化和被分配的了。

[传说的伙伴系统][6]

将内存划分为node/zone之后，分配内存时是不是有办法去控制从哪个node哪个zone上去分配呢？答案是有的。

[GFP的功效][20]

为了更好管理内存，内核中会给分配出去的内存做一些标记，这样方便在回收，出错等时候判断内存的用途。

为了更好的理解内存管理中的代码流程，我们需要了解[页分配器的用户们][19]

[1]: /mm/01-e820_retrieve_memory_from_HW.md
[2]: /mm/02-memblock.md
[3]: /mm/03-sparsemem.md
[5]: /mm/05-Node_Zone_Page.md
[6]: /mm/06-page_alloc.md
[7]: /mm/07-per_cpu_pageset.md
[8]: /mm/08-slub_general.md
[9]: /mm/09-slub_in_graph.md
[10]: /mm/10-page_struct.md
[11]: /mm/50-challenge_evolution.md
[18]: https://www.kernel.org/doc/gorman/html/understand/index.html
[19]: /mm/11-users_of_buddy.md
[20]: /mm/12-gfp_usage.md
[21]: /mm/13-physical-layer-partition.md
